<?xml version="1.0"?>
<!--
  ~ Copyright (c) 2019 Evolveum and contributors
  ~
  ~ This work is dual-licensed under the Apache License 2.0
  ~ and European Union Public License. See LICENSE file for details.
  -->

<objectTemplate oid="8098b124-c20c-4965-8adf-e528abedf7a4"
	xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
	xmlns='http://midpoint.evolveum.com/xml/ns/public/common/common-3'
	xmlns:c='http://midpoint.evolveum.com/xml/ns/public/common/common-3'
	xmlns:t='http://prism.evolveum.com/xml/ns/public/types-3'>
	
    <name>User Template</name>
    <iterationSpecification>
        <maxIterations>99</maxIterations>
        <tokenExpression>
            <script>
                <code>
                    if (iteration == 0) {
                        return "";
                    } else {
                        return "_"+iteration;
                    }
                </code>
            </script>
        </tokenExpression>
        <postIterationCondition>
            <variable>
                <name>givenName</name>
                <path>$focus/givenName</path>
            </variable>
            <variable>
                <name>familyName</name>
                <path>$focus/familyName</path>
            </variable>
            <script>
                <code>
				    import com.evolveum.midpoint.xml.ns._public.common.common_3.*
                    import com.evolveum.midpoint.schema.constants.*
                    import com.evolveum.midpoint.schema.* 
                    import javax.xml.namespace.*
                    import com.evolveum.midpoint.util.*
                    import com.evolveum.midpoint.prism.path.*
					import com.evolveum.midpoint.prism.polystring.*
					import com.evolveum.midpoint.prism.PrismContainer.*

					def nameunique = false
					def uidunique = false
					if (givenName == null || familyName == null) { 
						return true;
					} else {
						def testname = basic.norm(basic.stringify(givenName))?.tr(' ', '_') + '_' + basic.norm(basic.stringify(familyName))?.tr(' ', '_') + "" + iterationToken;
						//log.info('post-iterate for name for {}', testname.toString());
						//nameunique = midpoint.isUniquePropertyValue(focus, 'name', PolyString.fromOrig(testname.toString()));
						nameunique = midpoint.isUniquePropertyValue(focus, 'name', PolyString.fromOrig(testname.toString()));
						//midpoint.isUniquePropertyValue(focus, 'name', PolyString.fromOrig(testname.toString()));
											
						def testuid = basic.norm(basic.stringify(givenName))?.tr(' ', '_').substring(0,1) + basic.norm(basic.stringify(familyName))?.tr(' ', '_') + "" + iterationToken;
						//log.info('post-iterate for uid for {}', testname.toString());
						//uidunique = midpoint.isUniquePropertyValue(focus, 'UserID', PolyString.fromOrig(testuid.toString()));
						uidunique = midpoint.isUniquePropertyValue(focus, 'employeeNumber', testuid.toString());
					}
										
					return (nameunique &amp;&amp; uidunique)
					
                </code>
            </script>
        </postIterationCondition>
	</iterationSpecification>
	
	
	<item>
		<ref>name</ref>
		<mapping>
			<!--<trace>true</trace>-->
			<strength>weak</strength>
			<source>
				<path>familyName</path>
			</source>
			<source>
				<path>givenName</path>
			</source>
			<expression>
				<script>
					<language>http://midpoint.evolveum.com/xml/ns/public/expression/language#Groovy</language>
					<code>
					//log.info('mapping expression for {}', basic.norm(basic.stringify(givenName))?.tr(' ', '_') + '_' + basic.norm(basic.stringify(familyName))?.tr(' ', '_') + "" + iterationToken)
					basic.norm(basic.stringify(givenName))?.tr(' ', '_') + '_' + basic.norm(basic.stringify(familyName))?.tr(' ', '_') + "" + iterationToken
					</code>
				</script>
			</expression>
			<condition>
				<script>
					<code>givenName != null &amp;&amp; familyName != null</code>
				</script>
			</condition>
		</mapping>
	</item>
	<item>
		<ref>employeeNumber</ref>
		<mapping>
			<!--<trace>true</trace>-->
			<strength>weak</strength>
			<source>
				<path>familyName</path>
			</source>
			<source>
				<path>givenName</path>
			</source>
			<expression>
				<script>
					<language>http://midpoint.evolveum.com/xml/ns/public/expression/language#Groovy</language>
					<code>
					tmpGivenName = basic.norm(basic.stringify(givenName))?.tr(' ', '_')
                    tmpFamilyName = basic.norm(basic.stringify(familyName))?.tr(' ', '_')
					tmpGivenName.substring(0, 1) + tmpFamilyName + iterationToken
					</code>
				</script>
			</expression>
			<condition>
				<script>
					<code>givenName != null &amp;&amp; familyName != null</code>
				</script>
			</condition>
		</mapping>
	</item>

    <mapping>
        <strength>strong</strength>
        <source>
            <path>employeeNumber</path>
        </source>
        <expression>
            <script>
                <code>
                    import com.evolveum.midpoint.xml.ns._public.common.common_3.*
                    import com.evolveum.midpoint.schema.constants.*
                    import com.evolveum.midpoint.schema.* 
                    import javax.xml.namespace.*
                    import com.evolveum.midpoint.util.*
                    import com.evolveum.midpoint.prism.path.*
                    
                    GROUPER_RESOURCE_OID = '1eff65de-5bb6-483d-9edf-8cc2c2ee0233'
                    MEMBER_NAME = new QName(MidPointConstants.NS_RI, 'member')
                    
                    memberDef = prismContext.definitionFactory().createPropertyDefinition(MEMBER_NAME, DOMUtil.XSD_STRING)
                    memberDef.setMaxOccurs(-1)

                    shadowQuery = prismContext.queryFor(ShadowType.class)
                        .item(ShadowType.F_RESOURCE_REF).ref(GROUPER_RESOURCE_OID)
                        .and().item(ShadowType.F_SYNCHRONIZATION_SITUATION).eq(SynchronizationSituationType.LINKED)
                        .and().item(ShadowType.F_KIND).eq(ShadowKindType.ENTITLEMENT)
                        .and().item(ShadowType.F_INTENT).eq('group')
                        .and().block().item(ShadowType.F_DEAD).isNull().or().item(ShadowType.F_DEAD).eq(false).endBlock()
                        .and().item(ItemPath.create(ShadowType.F_ATTRIBUTES, MEMBER_NAME), memberDef).eq(basic.stringify(employeeNumber))
                        .build()
                        
                    //log.info('shadowQuery = {}\n{}', shadowQuery, shadowQuery.debugDump())
                    options = SelectorOptions.createCollection(GetOperationOptions.createNoFetch())
                    shadows = midpoint.searchObjects(ShadowType.class, shadowQuery, options)
                    //log.info('shadows found for {}: {}', employeeNumber, shadows)
                    
                    orgNames = shadows.collect { basic.stringify(it.name) }            // todo - use attributes
                    log.info('org names = {}', orgNames)
                    
                    if (!orgNames.isEmpty()) { 
                        orgQueryBuilder = prismContext.queryFor(OrgType.class)
                        
                        first = true
                        for (orgName in orgNames) {
                            if (first) {
                                first = false
                            } else {
                                orgQueryBuilder = orgQueryBuilder.or()
                            }
                            orgQueryBuilder = orgQueryBuilder.item(ItemPath.create(OrgType.F_EXTENSION, 'grouperName')).eq(orgName)
                        }
                            
                        orgQuery = orgQueryBuilder.build()
                        //log.info('org query:\n', orgQuery.debugDump())
                        
                        orgs = midpoint.searchObjects(OrgType.class, orgQuery, null)
                        log.info('orgs found: {}', orgs)
                        
                        orgs.collect {
                            new AssignmentType(prismContext)
                                .subtype('grouper-group')
                                .targetRef(it.oid, OrgType.COMPLEX_TYPE)
                        }
                    } else {
                        null
                    }
                </code>
            </script>
        </expression>
        <target>
            <path>assignment</path>
            <set>
                <condition>
                    <script>
                        <code>
                            assignment?.subtype.contains('grouper-group')
                        </code>
                    </script>
                </condition>
            </set>
        </target>
    </mapping>
</objectTemplate>
